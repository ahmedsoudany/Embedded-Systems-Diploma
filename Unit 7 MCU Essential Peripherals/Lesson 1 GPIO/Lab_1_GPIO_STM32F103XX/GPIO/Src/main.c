/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  //#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
/*====================Addresses================================*/
//Clock Enable Addresses
#define RCC_base                0x40021000
#define RCC_APB2ENR             *(volatile unsigned int *)(RCC_base + 0x18)

#define IOPAEN (1<<2)
#define IOPBEN (1<<3)

//GPIO Addresses
#define GPIOA_base              0x40010800
#define GPIOA_CRL               *((volatile unsigned int *)(GPIOA_base + 0x00))
#define GPIOA_CRH               *((volatile unsigned int *)(GPIOA_base + 0x04))
#define GPIOA_ODR               *((volatile unsigned int *)(GPIOA_base + 0x0C))
#define GPIOA_IDR               *((volatile unsigned int *)(GPIOA_base + 0x08))

#define GPIOB_base               0x40010C00
#define GPIOB_CRL               *((volatile unsigned int *)(GPIOB_base + 0x00))
#define GPIOB_CRH               *((volatile unsigned int *)(GPIOB_base + 0x04))
#define GPIOB_ODR               *((volatile unsigned int *)(GPIOB_base + 0x0C))
#define GPIOB_IDR               *((volatile unsigned int *)(GPIOB_base + 0x08))
#define ODR1 (1<<1)
#define ODR13 (1<<13)



void clock_init()
{
    //IO port A clock enable
    RCC_APB2ENR |= IOPAEN;
    //IO port B clock enable
    RCC_APB2ENR |= IOPBEN;
}

void GPIO_Init()
{

	GPIOA_CRL = 0x0;
	GPIOA_CRH = 0x0;
	GPIOA_ODR = 0x0;


	//00: Input mode
	GPIOA_CRL |= 0x00000040;
	//GPIOA_CRL &= ~(0b11 << 4);
	//CNF 01:Floating input(PA1)
	//GPIOA_CRL |=  (0b01 << 6);

	//Mode: push-pull(PB1),max speed 10MHz
	GPIOB_CRL |= 0x00000010;
	//GPIOB_CRL |= (0b01 << 4);
	//CNF 00: General purpose output
	//GPIOB_CRL &= ~(0b11 << 6);


	//=========================================

	//00: Input mode
	//GPIOA_CRH &= ~(0b11 << 20);
	//CNF 01::Floating input(PA13)
	//GPIOA_CRH |= (0b01 << 22);
	GPIOA_CRH |= 0x00400000;

	//Mode: Open Drain(PB13),max speed 10MHz
	GPIOB_CRH |= 0x00100000;
	//GPIOB_CRH |= (0b01 << 20);
	//CNF 00:General purpose output push-pull(PB13),max speed 10MHz
	//GPIOB_CRH &= ~(0b11 << 22);


}



void wait_ms(uint32_t time)
{
    uint32_t i,j;
    for(i = 0; i < time; i++)
        for(j = 0; j < 255; j++);
}

int main(void)
{
    clock_init();
    GPIO_Init();

   GPIOB_ODR |= ODR1;                      // LED 1 initially OFF
   GPIOB_ODR |= ODR13;					   // LED 1 initially ON
   while(1)
   {
       //PA1 >> Connected to external PUR
       if(((GPIOA_IDR & ODR1) >> 1) == 0)
       {
           GPIOB_ODR ^= ODR1;
           while (((GPIOA_IDR & ODR1) >> 1) == 0); //Single pressing
       }
       //PA13 >> Connected to external PDR
       if(((GPIOA_IDR & ODR13) >> 13) == 1) //Multi pressing
           {
               GPIOB_ODR ^= ODR13;
               wait_ms(40);
           }
   }
}

