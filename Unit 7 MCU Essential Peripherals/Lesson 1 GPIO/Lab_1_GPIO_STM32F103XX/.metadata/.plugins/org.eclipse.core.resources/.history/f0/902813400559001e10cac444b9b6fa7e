/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
/*====================Addresses================================*/
//Clock Enable Addresses
#define RCC_base 0x40021000
#define RCC_CFGR *(volatile unsigned int *)(RCC_base + 0x04)
#define RCC_APB2ENR *(volatile unsigned int *)(RCC_base + 0x18)

#define IOPAEN (1<<2)
#define IOPBEN (1<<3)
#define MCO 0x500000
//GPIO Addresses
#define GPIOA_base 0x40010800
#define GPIOA_CRL *(volatile unsigned int *)(GPIOA_base + 0x00)
#define GPIOA_CRH *(volatile unsigned int *)(GPIOA_base + 0x04)
#define GPIOA_ODR *(volatile unsigned int *)(GPIOA_base + 0x0C)
#define GPIOA_IDR *(volatile unsigned int *)(GPIOA_base + 0x08)
#define GPIOB_base 0x40010C00
#define GPIOB_CRL *(volatile unsigned int *)(GPIOB_base + 0x00)
#define GPIOB_CRH *(volatile unsigned int *)(GPIOB_base + 0x04)
#define GPIOB_ODR *(volatile unsigned int *)(GPIOB_base + 0x0C)
#define GPIOB_IDR *(volatile unsigned int *)(GPIOB_base + 0x08)
#define ODR1 (1<<1)
#define ODR13 (1<<13)
void clock_init()
{
	//HSI clock selected
	RCC_CFGR |= MCO;
	//IO port A clock enable and IO port B clock enable
	RCC_APB2ENR |= IOPAEN | IOPBEN;
}
void GPIO_output_pins() //B1 and B13
{
	GPIOB_CRL = 0;
	GPIOB_CRH = 0;
	//General purpose output push-pull(P1),max speed 10MHz
	GPIOB_CRL |= 0x10;
	//General purpose output push-pull(P13),max speed 10MHz
	GPIOB_CRH |= 0x100000;
	//Making P1 and P13 floating
	GPIOB_ODR |= ODR1 | ODR13;
}
void GPIO_input_pins() //A1 and A13
{
	GPIOA_CRL = 0;
	GPIOA_CRH = 0;
	//Input mode :Floating input(A1)
	GPIOA_CRL |= 0x40;
	//Input mode :Floating input(A13)
	GPIOB_CRH |= 0x400000;

}

void wait_ms(uint32_t time)
{
	uint32_t i,j;
	for(i = 0; i < time; i++)
		for(j = 0; i < 255; j++);
}

int main(void)
{
	clock_init();
	GPIO_output_pins();
	GPIO_input_pins();

   while(1)
   {
	   if((GPIOA_IDR & (1<<1) >> 1) == 0)
	   {
		   GPIOA_ODR ^= 1<<1;
		   while((GPIOA_IDR & (1<<1) >> 1) == 0); //Single pressing
	   }
	   if((GPIOA_IDR & (1<<13) >> 1) == 1) //Multi pressing
	   	   {
	   		   GPIOA_ODR ^= 1<<13;
	   	   }
	   wait_ms(1);
   }
}
