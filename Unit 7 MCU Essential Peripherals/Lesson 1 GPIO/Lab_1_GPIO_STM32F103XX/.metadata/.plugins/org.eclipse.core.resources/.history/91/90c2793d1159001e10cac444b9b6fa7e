/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

//#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  //#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
//#endif

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
/*====================Addresses================================*/
//Clock Enable Addresses
#define RCC_base 0x40021000
#define RCC_CFGR    *(volatile unsigned int *)(RCC_base + 0x04)
#define RCC_APB2ENR *(volatile unsigned int *)(RCC_base + 0x18)

#define IOPAEN (1<<2)
#define IOPBEN (1<<3)

//GPIO Addresses
#define GPIOA_base 0x40010800
#define GPIOA_CRL *(volatile unsigned int *)(GPIOA_base + 0x00)
#define GPIOA_CRH *(volatile unsigned int *)(GPIOA_base + 0x04)
#define GPIOA_ODR *(volatile unsigned int *)(GPIOA_base + 0x0C)
#define GPIOA_IDR *(volatile unsigned int *)(GPIOA_base + 0x08)

#define GPIOB_base 0x40010C00
#define GPIOB_CRL *(volatile unsigned int *)(GPIOB_base + 0x00)
#define GPIOB_CRH *(volatile unsigned int *)(GPIOB_base + 0x04)
#define GPIOB_ODR *(volatile unsigned int *)(GPIOB_base + 0x0C)
#define GPIOB_IDR *(volatile unsigned int *)(GPIOB_base + 0x08)
#define ODR1 (1<<1)
#define ODR13 (1UL<<13)
void clock_init()
{
	//HSI clock selected
	//RCC_CFGR |= MCO;
	//IO port A clock enable and IO port B clock enable
	RCC_APB2ENR |= IOPAEN;
	RCC_APB2ENR	|= IOPBEN;
}
void GPIO_output_pins() //PB1 and PB13
{
	GPIOB_CRL = 0x0;
	GPIOB_CRH = 0x0;
	//General purpose output push-pull(PB1),max speed 10MHz
	//GPIOB_CRL |= 0x00000010;
	GPIOB_CRL |= (0b01 << 4);
	GPIOB_CRL &= ~(0b11 << 6);
	//General purpose output push-pull(PB13),max speed 10MHz
	//GPIOB_CRH |= 0x00100000;
	GPIOB_CRH |= (0b01 << 20);
	GPIOB_CRH &= ~(0b11 << 22);


}
void GPIO_input_pins() //A1 and A13
{
	GPIOA_CRL = 0x0;
	GPIOA_CRH = 0x0;
	GPIOB_ODR = 0x0;
	//Input mode :Floating input(PA1)
	//GPIOA_CRL |= 0x00000040;
	GPIOA_CRL &= ~(0b11 << 4);
	GPIOA_CRL |=  (0b01 << 6);
	//Input mode :Floating input(PA13)
	GPIOA_CRH &= ~(0b11 << 20);
	GPIOA_CRH |=  (0b01 << 22);
	//GPIOB_CRH |= 0x00400000;

}

void wait_ms(uint32_t time)
{
	uint32_t i,j;
	for(i = 0; i < time; i++)
		for(j = 0; i < 255; j++);
}

int main(void)
{
	clock_init();
	GPIO_output_pins();
	GPIO_input_pins();

   while(1)
   {
	   //PA1 >> Connected to external PUR
	   if((GPIOA_IDR & (1<<1) >> 1) == 0)
	   {
		   GPIOA_ODR ^= ODR1;
		   while((GPIOA_IDR & (1<<1) >> 1) == 0); //Single pressing
	   }
	   //PA13 >> Connected to external PDR
	   if((GPIOA_IDR & (1<<13) >> 13) == 1) //Multi pressing
	   	   {
	   		   GPIOA_ODR ^= ODR13;
	   	   }
	   wait_ms(1);
   }
}
